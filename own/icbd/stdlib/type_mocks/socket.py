# generated with make_mock.py

AF_APPLETALK = 5
AF_ASH = 18
AF_ATMPVC = 8
AF_ATMSVC = 20
AF_AX25 = 3
AF_BLUETOOTH = 31
AF_BRIDGE = 7
AF_DECnet = 12
AF_ECONET = 19
AF_INET = 2
AF_INET6 = 10
AF_IPX = 4
AF_IRDA = 23
AF_KEY = 15
AF_LLC = 26
AF_NETBEUI = 13
AF_NETLINK = 16
AF_NETROM = 6
AF_PACKET = 17
AF_PPPOX = 24
AF_ROSE = 11
AF_ROUTE = 16
AF_SECURITY = 14
AF_SNA = 22
AF_TIPC = 30
AF_UNIX = 1
AF_UNSPEC = 0
AF_WANPIPE = 25
AF_X25 = 9
AI_ADDRCONFIG = 32
AI_ALL = 16
AI_CANONNAME = 2
AI_NUMERICHOST = 4
AI_NUMERICSERV = 1024
AI_PASSIVE = 1
AI_V4MAPPED = 8
BDADDR_ANY = '00:00:00:00:00:00'
BDADDR_LOCAL = '00:00:00:FF:FF:FF'
BTPROTO_HCI = 1
BTPROTO_L2CAP = 0
BTPROTO_RFCOMM = 3
BTPROTO_SCO = 2
EAI_ADDRFAMILY = -9
EAI_AGAIN = -3
EAI_BADFLAGS = -1
EAI_FAIL = -4
EAI_FAMILY = -6
EAI_MEMORY = -10
EAI_NODATA = -5
EAI_NONAME = -2
EAI_OVERFLOW = -12
EAI_SERVICE = -8
EAI_SOCKTYPE = -7
EAI_SYSTEM = -11
EBADF = 9
EINTR = 4
HCI_DATA_DIR = 1
HCI_FILTER = 2
HCI_TIME_STAMP = 3
INADDR_ALLHOSTS_GROUP = 3758096385
INADDR_ANY = 0
INADDR_BROADCAST = 4294967295
INADDR_LOOPBACK = 2130706433
INADDR_MAX_LOCAL_GROUP = 3758096639
INADDR_NONE = 4294967295
INADDR_UNSPEC_GROUP = 3758096384
IPPORT_RESERVED = 1024
IPPORT_USERRESERVED = 5000
IPPROTO_AH = 51
IPPROTO_DSTOPTS = 60
IPPROTO_EGP = 8
IPPROTO_ESP = 50
IPPROTO_FRAGMENT = 44
IPPROTO_GRE = 47
IPPROTO_HOPOPTS = 0
IPPROTO_ICMP = 1
IPPROTO_ICMPV6 = 58
IPPROTO_IDP = 22
IPPROTO_IGMP = 2
IPPROTO_IP = 0
IPPROTO_IPIP = 4
IPPROTO_IPV6 = 41
IPPROTO_NONE = 59
IPPROTO_PIM = 103
IPPROTO_PUP = 12
IPPROTO_RAW = 255
IPPROTO_ROUTING = 43
IPPROTO_RSVP = 46
IPPROTO_TCP = 6
IPPROTO_TP = 29
IPPROTO_UDP = 17
IPV6_CHECKSUM = 7
IPV6_DSTOPTS = 59
IPV6_HOPLIMIT = 52
IPV6_HOPOPTS = 54
IPV6_JOIN_GROUP = 20
IPV6_LEAVE_GROUP = 21
IPV6_MULTICAST_HOPS = 18
IPV6_MULTICAST_IF = 17
IPV6_MULTICAST_LOOP = 19
IPV6_NEXTHOP = 9
IPV6_PKTINFO = 50
IPV6_RECVDSTOPTS = 58
IPV6_RECVHOPLIMIT = 51
IPV6_RECVHOPOPTS = 53
IPV6_RECVPKTINFO = 49
IPV6_RECVRTHDR = 56
IPV6_RECVTCLASS = 66
IPV6_RTHDR = 57
IPV6_RTHDRDSTOPTS = 55
IPV6_RTHDR_TYPE_0 = 0
IPV6_TCLASS = 67
IPV6_UNICAST_HOPS = 16
IPV6_V6ONLY = 26
IP_ADD_MEMBERSHIP = 35
IP_DEFAULT_MULTICAST_LOOP = 1
IP_DEFAULT_MULTICAST_TTL = 1
IP_DROP_MEMBERSHIP = 36
IP_HDRINCL = 3
IP_MAX_MEMBERSHIPS = 20
IP_MULTICAST_IF = 32
IP_MULTICAST_LOOP = 34
IP_MULTICAST_TTL = 33
IP_OPTIONS = 4
IP_RECVOPTS = 6
IP_RECVRETOPTS = 7
IP_RETOPTS = 7
IP_TOS = 1
IP_TTL = 2
MSG_CTRUNC = 8
MSG_DONTROUTE = 4
MSG_DONTWAIT = 64
MSG_EOR = 128
MSG_OOB = 1
MSG_PEEK = 2
MSG_TRUNC = 32
MSG_WAITALL = 256

class MethodType(object):
    pass

NETLINK_DNRTMSG = 14
NETLINK_FIREWALL = 3
NETLINK_IP6_FW = 13
NETLINK_NFLOG = 5
NETLINK_ROUTE = 0
NETLINK_USERSOCK = 2
NETLINK_XFRM = 6
NI_DGRAM = 16
NI_MAXHOST = 1025
NI_MAXSERV = 32
NI_NAMEREQD = 8
NI_NOFQDN = 4
NI_NUMERICHOST = 1
NI_NUMERICSERV = 2
PACKET_BROADCAST = 1
PACKET_FASTROUTE = 6
PACKET_HOST = 0
PACKET_LOOPBACK = 5
PACKET_MULTICAST = 2
PACKET_OTHERHOST = 3
PACKET_OUTGOING = 4
PF_PACKET = 17

def RAND_add(*args, **kw):
    pass

def RAND_egd(*args, **kw):
    pass

def RAND_status(*args, **kw):
    pass

SHUT_RD = 0
SHUT_RDWR = 2
SHUT_WR = 1
SOCK_DGRAM = 2
SOCK_RAW = 3
SOCK_RDM = 4
SOCK_SEQPACKET = 5
SOCK_STREAM = 1
SOL_HCI = 0
SOL_IP = 0
SOL_SOCKET = 1
SOL_TCP = 6
SOL_TIPC = 271
SOL_UDP = 17
SOMAXCONN = 128
SO_ACCEPTCONN = 30
SO_BROADCAST = 6
SO_DEBUG = 1
SO_DONTROUTE = 5
SO_ERROR = 4
SO_KEEPALIVE = 9
SO_LINGER = 13
SO_OOBINLINE = 10
SO_RCVBUF = 8
SO_RCVLOWAT = 18
SO_RCVTIMEO = 20
SO_REUSEADDR = 2
SO_SNDBUF = 7
SO_SNDLOWAT = 19
SO_SNDTIMEO = 21
SO_TYPE = 3
SSL_ERROR_EOF = 8
SSL_ERROR_INVALID_ERROR_CODE = 9
SSL_ERROR_SSL = 1
SSL_ERROR_SYSCALL = 5
SSL_ERROR_WANT_CONNECT = 7
SSL_ERROR_WANT_READ = 2
SSL_ERROR_WANT_WRITE = 3
SSL_ERROR_WANT_X509_LOOKUP = 4
SSL_ERROR_ZERO_RETURN = 6

class socket(object):
    def accept(self):
        """Accept a connection. The socket must be bound to an address and listening for
           connections. The return value is a pair ``(conn, address)`` where *conn* is a
           *new* socket object usable to send and receive data on the connection, and
           *address* is the address bound to the socket on the other end of the connection."""

    def bind(self, address):
        """Bind the socket to *address*.  The socket must not already be bound. (The format
           of *address* depends on the address family --- see above.)"""

    def close(self):
        """Close the socket.  All future operations on the socket object will fail. The
           remote end will receive no more data (after queued data is flushed). Sockets are
           automatically closed when they are garbage-collected."""

    def connect(self, address):
        """Connect to a remote socket at *address*. (The format of *address* depends on the
           address family --- see above.)"""
        return None

    def connect_ex(self, address):
        """Like ``connect(address)``, but return an error indicator instead of raising an
           exception for errors returned by the C-level :c:func:`connect` call (other
           problems, such as "host not found," can still raise exceptions).  The error
           indicator is ``0`` if the operation succeeded, otherwise the value of the
           :c:data:`errno` variable.  This is useful to support, for example, asynchronous
           connects."""
        return 0

    def fileno(self):
        """Return the socket's file descriptor (a small integer).  This is useful with
           :func:`select.select`."""
        return 0

    def getpeername(self):
        """Return the remote address to which the socket is connected.  This is useful to
           find out the port number of a remote IPv4/v6 socket, for instance. (The format
           of the address returned depends on the address family --- see above.)  On some
           systems this function is not supported."""

    def getsockname(self):
        """Return the socket's own address.  This is useful to find out the port number of
           an IPv4/v6 socket, for instance. (The format of the address returned depends on
           the address family --- see above.)"""

    def getsockopt(self, level, optname, buflen=0):
        """Return the value of the given socket option (see the Unix man page
           :manpage:`getsockopt(2)`).  The needed symbolic constants (:const:`SO_\*` etc.)
           are defined in this module.  If *buflen* is absent, an integer option is assumed
           and its integer value is returned by the function.  If *buflen* is present, it
           specifies the maximum length of the buffer used to receive the option in, and
           this buffer is returned as a string.  It is up to the caller to decode the
           contents of the buffer (see the optional built-in module :mod:`struct` for a way
           to decode C structures encoded as strings)."""
        return ""

    def gettimeout(self):
        """Return the timeout in seconds (float) associated with socket operations, or
           ``None`` if no timeout is set.  This reflects the last call to
           :meth:`setblocking` or :meth:`settimeout`."""
        return 0.0

    def listen(self, backlog):
        """Listen for connections made to the socket.  The *backlog* argument specifies the
           maximum number of queued connections and should be at least 0; the maximum value
           is system-dependent (usually 5), the minimum value is forced to 0."""

    def makefile(self, mode='rw', bufsize=0):
        """.. index:: single: I/O control; buffering"""

    def sendall(self, string, flags=0):
        """Send data to the socket.  The socket must be connected to a remote socket.  The
           optional *flags* argument has the same meaning as for :meth:`recv` above.
           Unlike :meth:`send`, this method continues to send data from *string* until
           either all data has been sent or an error occurs.  ``None`` is returned on
           success.  On error, an exception is raised, and there is no way to determine how
           much data, if any, was successfully sent."""
        return None

    def setblocking(self, flag):
        """Set blocking or non-blocking mode of the socket: if *flag* is 0, the socket is
           set to non-blocking, else to blocking mode.  Initially all sockets are in
           blocking mode.  In non-blocking mode, if a :meth:`recv` call doesn't find any
           data, or if a :meth:`send` call can't immediately dispose of the data, a
           :exc:`error` exception is raised; in blocking mode, the calls block until they
           can proceed. ``s.setblocking(0)`` is equivalent to ``s.settimeout(0.0)``;
           ``s.setblocking(1)`` is equivalent to ``s.settimeout(None)``."""

    def setsockopt(self, level, optname, value):
        """.. index:: module: struct"""

    def settimeout(self, value):
        """Set a timeout on blocking socket operations.  The *value* argument can be a
           nonnegative float expressing seconds, or ``None``. If a float is given,
           subsequent socket operations will raise a :exc:`timeout` exception if the
           timeout period *value* has elapsed before the operation has completed.  Setting
           a timeout of ``None`` disables timeouts on socket operations.
           ``s.settimeout(0.0)`` is equivalent to ``s.setblocking(0)``;
           ``s.settimeout(None)`` is equivalent to ``s.setblocking(1)``."""

    def shutdown(self, how):
        """Shut down one or both halves of the connection.  If *how* is :const:`SHUT_RD`,
           further receives are disallowed.  If *how* is :const:`SHUT_WR`, further sends
           are disallowed.  If *how* is :const:`SHUT_RDWR`, further sends and receives are
           disallowed.  Depending on the platform, shutting down one half of the connection
           can also close the opposite half (e.g. on Mac OS X, ``shutdown(SHUT_WR)`` does
           not allow further reads on the other end of the connection)."""


TCP_CORK = 3
TCP_DEFER_ACCEPT = 9
TCP_INFO = 11
TCP_KEEPCNT = 6
TCP_KEEPIDLE = 4
TCP_KEEPINTVL = 5
TCP_LINGER2 = 8
TCP_MAXSEG = 2
TCP_NODELAY = 1
TCP_QUICKACK = 12
TCP_SYNCNT = 7
TCP_WINDOW_CLAMP = 10
TIPC_ADDR_ID = 3
TIPC_ADDR_NAME = 2
TIPC_ADDR_NAMESEQ = 1
TIPC_CFG_SRV = 0
TIPC_CLUSTER_SCOPE = 2
TIPC_CONN_TIMEOUT = 130
TIPC_CRITICAL_IMPORTANCE = 3
TIPC_DEST_DROPPABLE = 129
TIPC_HIGH_IMPORTANCE = 2
TIPC_IMPORTANCE = 127
TIPC_LOW_IMPORTANCE = 0
TIPC_MEDIUM_IMPORTANCE = 1
TIPC_NODE_SCOPE = 3
TIPC_PUBLISHED = 1
TIPC_SRC_DROPPABLE = 128
TIPC_SUBSCR_TIMEOUT = 3
TIPC_SUB_CANCEL = 4
TIPC_SUB_PORTS = 1
TIPC_SUB_SERVICE = 2
TIPC_TOP_SRV = 1
TIPC_WAIT_FOREVER = -1
TIPC_WITHDRAWN = 2
TIPC_ZONE_SCOPE = 1

def create_connection(address, timeout=0, source_address='0.0.0.0'):
    """Connect to a TCP service listening on the Internet *address* (a 2-tuple
       ``(host, port)``), and return the socket object.  This is a higher-level
       function than :meth:`socket.connect`: if *host* is a non-numeric hostname,
       it will try to resolve it for both :data:`AF_INET` and :data:`AF_INET6`,
       and then try to connect to all possible addresses in turn until a
       connection succeeds.  This makes it easy to write clients that are
       compatible to both IPv4 and IPv6."""
    return socket()

class error(IOError):
    pass

def fromfd(fd, family, type, proto=0):
    """Duplicate the file descriptor *fd* (an integer as returned by a file object's
       :meth:`fileno` method) and build a socket object from the result.  Address
       family, socket type and protocol number are as for the :func:`socket` function
       above. The file descriptor should refer to a socket, but this is not checked ---
       subsequent operations on the object may fail if the file descriptor is invalid.
       This function is rarely needed, but can be used to get or set socket options on
       a socket passed to a program as standard input or output (such as a server
       started by the Unix inet daemon).  The socket is assumed to be in blocking mode.
       Availability: Unix."""

class gaierror(error):
    pass

def getaddrinfo(host, port, family=0, socktype=0, proto=0, flags=0):
    """Translate the *host*/*port* argument into a sequence of 5-tuples that contain
       all the necessary arguments for creating a socket connected to that service.
       *host* is a domain name, a string representation of an IPv4/v6 address
       or ``None``. *port* is a string service name such as ``'http'``, a numeric
       port number or ``None``.  By passing ``None`` as the value of *host*
       and *port*, you can pass ``NULL`` to the underlying C API."""

def getdefaulttimeout():
    """Return the default timeout in seconds (float) for new socket objects. A value
       of ``None`` indicates that new socket objects have no timeout. When the socket
       module is first imported, the default is ``None``."""
    return None

def getfqdn(name=''):
    """Return a fully qualified domain name for *name*. If *name* is omitted or empty,
       it is interpreted as the local host.  To find the fully qualified name, the
       hostname returned by :func:`gethostbyaddr` is checked, followed by aliases for the
       host, if available.  The first name which includes a period is selected.  In
       case no fully qualified domain name is available, the hostname as returned by
       :func:`gethostname` is returned."""
    return ''

def gethostbyaddr(ip_address):
    """Return a triple ``(hostname, aliaslist, ipaddrlist)`` where *hostname* is the
       primary host name responding to the given *ip_address*, *aliaslist* is a
       (possibly empty) list of alternative host names for the same address, and
       *ipaddrlist* is a list of IPv4/v6 addresses for the same interface on the same
       host (most likely containing only a single address). To find the fully qualified
       domain name, use the function :func:`getfqdn`. :func:`gethostbyaddr` supports
       both IPv4 and IPv6."""
    return ('', [''], [''])

def gethostbyname(hostname):
    """Translate a host name to IPv4 address format.  The IPv4 address is returned as a
       string, such as  ``'100.50.200.5'``.  If the host name is an IPv4 address itself
       it is returned unchanged.  See :func:`gethostbyname_ex` for a more complete
       interface. :func:`gethostbyname` does not support IPv6 name resolution, and
       :func:`getaddrinfo` should be used instead for IPv4/v6 dual stack support."""
    return '0.0.0.0'

def gethostbyname_ex(hostname):
    """Translate a host name to IPv4 address format, extended interface. Return a
       triple ``(hostname, aliaslist, ipaddrlist)`` where *hostname* is the primary
       host name responding to the given *ip_address*, *aliaslist* is a (possibly
       empty) list of alternative host names for the same address, and *ipaddrlist* is
       a list of IPv4 addresses for the same interface on the same host (often but not
       always a single address). :func:`gethostbyname_ex` does not support IPv6 name
       resolution, and :func:`getaddrinfo` should be used instead for IPv4/v6 dual
       stack support."""
    return ('', [''], [''])

def gethostname():
    """Return a string containing the hostname of the machine where  the Python
       interpreter is currently executing."""
    return 'kmod-work-desktop'

def getnameinfo(sockaddr, flags):
    """Translate a socket address *sockaddr* into a 2-tuple ``(host, port)``. Depending
       on the settings of *flags*, the result can contain a fully-qualified domain name
       or numeric address representation in *host*.  Similarly, *port* can contain a
       string port name or a numeric port number."""
    return ('', 0)

def getprotobyname(protocolname):
    """Translate an Internet protocol name (for example, ``'icmp'``) to a constant
       suitable for passing as the (optional) third argument to the :func:`socket`
       function.  This is usually only needed for sockets opened in "raw" mode
       (:const:`SOCK_RAW`); for the normal socket modes, the correct protocol is chosen
       automatically if the protocol is omitted or zero."""

def getservbyname(servicename, protocolname="tcp"):
    """Translate an Internet service name and protocol name to a port number for that
       service.  The optional protocol name, if given, should be ``'tcp'`` or
       ``'udp'``, otherwise any protocol will match."""
    return 0

def getservbyport(port, protocolname="tcp"):
    """Translate an Internet port number and protocol name to a service name for that
       service.  The optional protocol name, if given, should be ``'tcp'`` or
       ``'udp'``, otherwise any protocol will match."""
    return 'tcpmux'

has_ipv6 = True

class herror(error):
    pass

def htonl(x):
    """Convert 32-bit positive integers from host to network byte order.  On machines
       where the host byte order is the same as network byte order, this is a no-op;
       otherwise, it performs a 4-byte swap operation."""
    return 0L

def htons(x):
    """Convert 16-bit positive integers from host to network byte order.  On machines
       where the host byte order is the same as network byte order, this is a no-op;
       otherwise, it performs a 2-byte swap operation."""
    return 0

def inet_aton(ip_string):
    """Convert an IPv4 address from dotted-quad string format (for example,
       '123.45.67.89') to 32-bit packed binary format, as a string four characters in
       length.  This is useful when conversing with a program that uses the standard C
       library and needs objects of type :c:type:`struct in_addr`, which is the C type
       for the 32-bit packed binary this function returns."""

def inet_ntoa(packed_ip):
    """Convert a 32-bit packed IPv4 address (a string four characters in length) to its
       standard dotted-quad string representation (for example, '123.45.67.89').  This
       is useful when conversing with a program that uses the standard C library and
       needs objects of type :c:type:`struct in_addr`, which is the C type for the
       32-bit packed binary data this function takes as an argument."""

def inet_ntop(address_family, packed_ip):
    """Convert a packed IP address (a string of some number of characters) to its
       standard, family-specific string representation (for example, ``'7.10.0.5'`` or
       ``'5aef:2b::8'``) :func:`inet_ntop` is useful when a library or network protocol
       returns an object of type :c:type:`struct in_addr` (similar to :func:`inet_ntoa`)
       or :c:type:`struct in6_addr`."""

def inet_pton(address_family, ip_string):
    """Convert an IP address from its family-specific string format to a packed, binary
       format. :func:`inet_pton` is useful when a library or network protocol calls for
       an object of type :c:type:`struct in_addr` (similar to :func:`inet_aton`) or
       :c:type:`struct in6_addr`."""

def ntohl(x):
    """Convert 32-bit positive integers from network to host byte order.  On machines
       where the host byte order is the same as network byte order, this is a no-op;
       otherwise, it performs a 4-byte swap operation."""
    return 0L

def ntohs(x):
    """Convert 16-bit positive integers from network to host byte order.  On machines
       where the host byte order is the same as network byte order, this is a no-op;
       otherwise, it performs a 2-byte swap operation."""
    return 0

def setdefaulttimeout(timeout):
    """Set the default timeout in seconds (float) for new socket objects. A value of
       ``None`` indicates that new socket objects have no timeout. When the socket
       module is first imported, the default is ``None``."""
    return None

def socketpair(family=AF_UNIX, type=None, proto="tcp"):
    """Build a pair of connected socket objects using the given address family, socket
       type, and protocol number.  Address family, socket type, and protocol number are
       as for the :func:`socket` function above. The default family is :const:`AF_UNIX`
       if defined on the platform; otherwise, the default is :const:`AF_INET`.
       Availability: Unix."""

class sslerror(error):
    pass

class timeout(error):
    pass

